import * as vscode from 'vscode';
import { SpeechRecognizer } from './SpeechRecognizer';

type IntentType = 'function' | 'class' | 'loop' | 'generic';

interface SpeechIntent {
  type: IntentType;
  name: string;
  parameters: string[];
  returnType: string;
  description: string;
}

interface CodeStructure {
  code: string;
  type: IntentType;
  language: 'typescript' | 'javascript';
}

export class VoiceCommandService {
  private isListening = false;
  private speechRecognizer: SpeechRecognizer;

  constructor() {
    this.speechRecognizer = new SpeechRecognizer();
  }

  public async startVoiceRecognition(): Promise<void> {
    if (this.isListening) {
      this.stopVoiceRecognition();
      return;
    }

    this.isListening = true;
    vscode.window.showInformationMessage('ðŸŽ¤ Agent 8: Listening for voice commands...');

    try {
      const transcript = await this.speechRecognizer.startRecognition();
      const code = await this.convertSpeechToCode(transcript);
      this.insertVoiceGeneratedCode(code, transcript);
    } catch (error: any) {
      vscode.window.showErrorMessage(`Voice recognition failed: ${error}`);
    } finally {
      this.isListening = false;
    }
  }

  public stopVoiceRecognition(): void {
    this.isListening = false;
    this.speechRecognizer.stopRecognition();
    vscode.window.showInformationMessage('ðŸŽ¤ Agent 8: Voice recognition stopped');
  }

  private async convertSpeechToCode(transcript: string): Promise<string> {
    const intent = this.analyzeSpeechIntent(transcript);
    const codeStructure = this.generateCodeStructure(intent);
    return this.generateCompleteCode(codeStructure, transcript);
  }

  private analyzeSpeechIntent(transcript: string): SpeechIntent {
    const lowerTranscript = transcript.toLowerCase();

    if (lowerTranscript.includes('function') || lowerTranscript.includes('create')) {
      return this.analyzeFunctionIntent(transcript);
    } else if (lowerTranscript.includes('class') || lowerTranscript.includes('interface')) {
      return this.analyzeClassIntent(transcript);
    } else if (lowerTranscript.includes('loop') || lowerTranscript.includes('for each') || lowerTranscript.includes('for ')) {
      return this.analyzeLoopIntent(transcript);
    } else {
      return this.analyzeGenericIntent(transcript);
    }
  }

  private analyzeFunctionIntent(transcript: string): SpeechIntent {
    const functionName = this.extractFunctionName(transcript);
    const parameters = this.extractParameters(transcript);

    return {
      type: 'function',
      name: functionName,
      parameters: parameters,
      returnType: this.inferReturnType(transcript),
      description: transcript,
    };
  }

  private extractFunctionName(transcript: string): string {
    // e.g. "create a function called add"
    const match = transcript.match(
      /(?:create|make|write)\s+(?:a\s+)?function\s+(?:called\s+)?([a-zA-Z_][a-zA-Z0-9_]*)/i
    );
    return match ? match[1] : 'generatedFunction';
  }

  private extractParameters(transcript: string): string[] {
    // e.g. "with parameters a and b" or "taking parameters a, b"
    const paramMatch = transcript.match(/(?:with|taking)\s+parameters?\s+([^.,]+)/i);
    return paramMatch ? paramMatch[1].split(/\s+and\s+|\s*,\s*/) : [];
  }

  private generateCodeStructure(intent: SpeechIntent): CodeStructure {
    switch (intent.type) {
      case 'function':
        return this.generateFunctionCode(intent);
      case 'class':
        return this.generateClassCode(intent);
      case 'loop':
        return this.generateLoopCode(intent);
      default:
        return this.generateGenericCode(intent);
    }
  }

  private generateFunctionCode(intent: SpeechIntent): CodeStructure {
    const params = intent.parameters.map((p) => `${p}: any`).join(', ');
    const returnType = intent.returnType || 'any';
    return {
      code: `function ${intent.name}(${params}): ${returnType} {\n  // TODO: Implement function logic\n  throw new Error('Function not implemented');\n}`,
      type: 'function',
      language: 'typescript',
    };
  }

  private insertVoiceGeneratedCode(code: string, transcript: string): void {
    const editor = vscode.window.activeTextEditor;
    if (editor) {
      const comment = `// Voice command: "${transcript}"\n// Generated by Agent 8 Voice-to-Code\n\n`;

      editor
        .edit((editBuilder) => {
          const position = editor.selection.active;
          editBuilder.insert(position, comment + code);
        })
        .then((success) => {
          if (success) {
            vscode.window.showInformationMessage('âœ… Code generated from voice command!');
          }
        });
    }
  }

  private analyzeClassIntent(transcript: string): SpeechIntent {
    return { type: 'class', name: 'GeneratedClass', parameters: [], returnType: 'void', description: transcript };
  }

  private analyzeLoopIntent(transcript: string): SpeechIntent {
    return { type: 'loop', name: 'generatedLoop', parameters: [], returnType: 'void', description: transcript };
  }

  private analyzeGenericIntent(transcript: string): SpeechIntent {
    return { type: 'generic', name: 'generatedCode', parameters: [], returnType: 'void', description: transcript };
  }

  private inferReturnType(transcript: string): string {
    const lower = transcript.toLowerCase();
    if (lower.includes('number') || lower.includes('calculate')) {
      return 'number';
    }
    if (lower.includes('string') || lower.includes('text')) {
      return 'string';
    }
    if (lower.includes('boolean') || lower.includes('check')) {
      return 'boolean';
    }
    return 'any';
  }

  private generateCompleteCode(structure: CodeStructure, _transcript: string): string {
    return structure.code;
  }

  private generateClassCode(intent: SpeechIntent): CodeStructure {
    return {
      code: `class ${intent.name} {\n  // TODO: Implement class properties and methods\n}`,
      type: 'class',
      language: 'typescript',
    };
  }

  private generateLoopCode(_intent: SpeechIntent): CodeStructure {
    return {
      code: `for (let i = 0; i < 10; i++) {\n  // TODO: Implement loop body\n}`,
      type: 'loop',
      language: 'typescript',
    };
  }

  private generateGenericCode(_intent: SpeechIntent): CodeStructure {
    return {
      code: `// TODO: Implement generated code block`,
      type: 'generic',
      language: 'typescript',
    };
  }
}